---
import Icon from '../ui/Icon.astro';
import { SITE, NAVIGATION } from '../../site.config';

const pathname = Astro.url.pathname;
const isActive = (path: string) => {
  if (path === '/') return pathname === '/';
  // Fix: Match general section for course content even if href is a deep link
  if (path.startsWith('/course/') && pathname.startsWith('/course/')) return true;
  if (path.length > 1 && pathname.startsWith(path)) return true;
  return false;
};

const showFocusToggle = pathname.startsWith('/course/');
const showPodcastToggle = pathname.startsWith('/course/');
---

<nav class="floating-menu">
  <div class="menu-pill">
    <div class="links">
        <!-- Home Link (Manual for Icon) -->
      <a href="/" class={`nav-link ${isActive('/') ? 'active' : ''}`} data-astro-prefetch>
        <Icon name="home" size={16} /> INÍCIO
      </a>
      
      <!-- Dynamic Navigation -->
      {NAVIGATION.map(item => {
        // Skip GitHub as we treat it specially with icon or allow it if desired. 
        // For now I'll check label to map icons manually or generic
        type MenuIcon = 'book-open' | 'graduation-cap' | 'terminal';
        let icon: MenuIcon = 'book-open'; // Changed defaults to match valid Icon types
        if (item.label === "Curso") icon = "graduation-cap";
        if (item.label === "Playground") icon = "terminal";
        if (item.label === "GitHub") return null; // Handle manually below

        return (
            <a href={item.href} class={`nav-link ${isActive(item.href) ? 'active' : ''}`} data-astro-prefetch>
                <Icon name={icon} size={16} /> {item.label.toUpperCase()}
            </a>
        )
      })}

      <!-- External Links -->
      <a href={SITE.github} target="_blank" class="nav-link">
        <Icon name="github" size={16} /> GITHUB
      </a>

      {showFocusToggle && (
        <button id="focus-toggle" class="nav-link focus-toggle" type="button" aria-pressed="false">
          <Icon name="align-left" size={16} /> FOCO
        </button>
      )}

      {showPodcastToggle && (
        <button id="podcast-toggle" class="nav-link focus-toggle" type="button" aria-pressed="false">
          <Icon name="play" size={16} /> PODCAST
        </button>
      )}
    </div>
  </div>
</nav>

<script>
  let cleanupFn: (() => void) | null = null;
  let focusCleanupFn: (() => void) | null = null;
  let podcastCleanupFn: (() => void) | null = null;

  const FOCUS_KEY = 'focus-mode';
  const PODCAST_KEY = 'podcast-mode';

  function setFocusMode(enabled: boolean) {
    document.body.classList.toggle('focus-mode', enabled);

    const btn = document.getElementById('focus-toggle');
    if (btn instanceof HTMLButtonElement) {
      btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
      btn.classList.toggle('active', enabled);
    }

    try {
      localStorage.setItem(FOCUS_KEY, enabled ? '1' : '0');
    } catch {}

    const sidebar = document.querySelector('.sidebar');
    if (enabled && sidebar instanceof HTMLElement) {
      sidebar.classList.remove('mobile-open');
      document.body.classList.remove('overflow-hidden');
    }

    // Fullscreen Logic
    if (enabled) {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {
          // Ignore failures (e.g. user interacting with popup)
        });
      }
    } else {
      if (document.fullscreenElement) {
        document.exitFullscreen().catch(() => {});
      }
    }
  }

  function setupFocusToggle() {
    if (focusCleanupFn) {
      focusCleanupFn();
      focusCleanupFn = null;
    }

    const btn = document.getElementById('focus-toggle');
    if (!(btn instanceof HTMLButtonElement)) {
      document.body.classList.remove('focus-mode');
      return;
    }

    let enabled = false;
    try {
      enabled = localStorage.getItem(FOCUS_KEY) === '1';
    } catch {}

    // Apply initial state without forcing fullscreen immediately on page load
    // (Browsers block automatic fullscreen without user interaction)
    document.body.classList.toggle('focus-mode', enabled);
    btn.classList.toggle('active', enabled);
    btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
    
    // We do NOT call setFocusMode(enabled) here because it would trigger requestFullscreen()
    // which fails on page load. We just sync the UI/CSS class.

    const onClick = () => {
      const next = !document.body.classList.contains('focus-mode');
      setFocusMode(next);
    };
    
    // Sync when user presses ESC or F11
    const onFullscreenChange = () => {
      const isFullscreen = !!document.fullscreenElement;
      // If we exited fullscreen, disable focus mode
      if (!isFullscreen && document.body.classList.contains('focus-mode')) {
        setFocusMode(false);
      }
    };

    btn.addEventListener('click', onClick);
    document.addEventListener('fullscreenchange', onFullscreenChange);
    
    focusCleanupFn = () => {
      btn.removeEventListener('click', onClick);
      document.removeEventListener('fullscreenchange', onFullscreenChange);
    };
  }

  function setPodcastMode(enabled: boolean) {
    document.body.classList.toggle('podcast-mode', enabled);

    const btn = document.getElementById('podcast-toggle');
    if (btn instanceof HTMLButtonElement) {
      btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
      btn.classList.toggle('active', enabled);
    }

    try {
      localStorage.setItem(PODCAST_KEY, enabled ? '1' : '0');
    } catch {}

    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('podcast-mode-change', { detail: { enabled } }));
    }
  }

  function setupPodcastToggle() {
    if (podcastCleanupFn) {
      podcastCleanupFn();
      podcastCleanupFn = null;
    }

    const btn = document.getElementById('podcast-toggle');
    if (!(btn instanceof HTMLButtonElement)) {
      document.body.classList.remove('podcast-mode');
      return;
    }

    let enabled = false;
    try {
      enabled = localStorage.getItem(PODCAST_KEY) === '1';
    } catch {}

    setPodcastMode(enabled);

    const onClick = () => {
      const next = !document.body.classList.contains('podcast-mode');
      setPodcastMode(next);
    };

    btn.addEventListener('click', onClick);
    podcastCleanupFn = () => btn.removeEventListener('click', onClick);
  }

  function setupScrollMenu() {
    // Cleanup previous listener
    if (cleanupFn) {
      cleanupFn();
      cleanupFn = null;
    }

    const menu = document.querySelector('.floating-menu');
    if (!menu) return;

    // Detect scroll target: .content-area for DocLayout, window for others
    const contentArea = document.querySelector('.content-area');
    const scrollTarget = contentArea || window;

    // Helper to get current Scroll Y
    const getScrollY = () => contentArea ? contentArea.scrollTop : window.scrollY;

    let lastScrollY = getScrollY();

    const onScroll = () => {
      const currentScrollY = getScrollY();
      
      // Threshold validation to avoid jitter
      if (Math.abs(currentScrollY - lastScrollY) < 10) return;

      // Hide on scroll down (>50px), Show on scroll up
      // Note: We use a slightly higher threshold when inside a container 
      if (currentScrollY > 50 && currentScrollY > lastScrollY) {
        menu.classList.add('menu-hidden');
      } else {
        menu.classList.remove('menu-hidden');
      }
      
      lastScrollY = currentScrollY;
    };

    // Attach listener to the correct target
    scrollTarget.addEventListener('scroll', onScroll, { passive: true });
    
    // Store cleanup function
    cleanupFn = () => scrollTarget.removeEventListener('scroll', onScroll);
  }

  // Initialize on first load
  setupScrollMenu();
  setupFocusToggle();
  setupPodcastToggle();

  // Allow other components (overlay) to close/open podcast mode without duplicar lógica
  (window as any).__setPodcastMode = setPodcastMode;

  // Re-initialize on View Transitions navigation
  document.addEventListener('astro:page-load', () => {
    setupScrollMenu();
    setupFocusToggle();
    setupPodcastToggle();
  });
</script>

<style>
  .floating-menu {
    position: fixed;
    top: 24px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    z-index: 100;
    pointer-events: none;
    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.4s ease; /* Premium Smoothness */
  }

  .floating-menu.menu-hidden {
    transform: translateY(-100px);
    opacity: 0;
  }
  
  @media (max-width: 768px) {
    .floating-menu {
      display: none !important;
    }
  }

  .menu-pill {
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(10, 10, 10, 0.8); /* Almost pure black */
    backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 6px; 
    border-radius: 9999px;
    box-shadow: 0 4px 40px rgba(0, 0, 0, 0.5);
    pointer-events: auto;
  }

  /* Logo */
  .logo {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 700;
    font-size: 15px;
    color: #fff;
    letter-spacing: -0.02em;
    text-decoration: none;
  }

  .logo-icon {
    width: 18px;
    height: 18px;
    background: linear-gradient(135deg, #3291ff, #7928ca); /* Vercel Blue/Purple */
    border-radius: 4px;
  }

  .highlight { color: #666; margin-left: 2px; }

  /* Links */
  .links {
    display: flex;
    align-items: center;
    gap: 8px; /* Compact links */
  }

  .nav-link {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #888;
    text-decoration: none;
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    transition: all 0.2s;
    padding: 0 16px;
    height: 32px;
    border-radius: 20px;
    white-space: nowrap;
  }

  .focus-toggle {
    background: transparent;
    border: 0;
    cursor: pointer;
  }

  .nav-link:hover {
    color: #fff;
    background: rgba(255,255,255,0.05);
  }

  /* Navigation Links Active State (Where I am) */
  a.nav-link.active {
    color: #fff;
    background: rgba(255, 255, 255, 0.15);
    font-weight: 700;
  }

  /* Feature Toggles Active State (What is ON) */
  button.nav-link.active {
    background: rgba(74, 222, 128, 0.1);
    color: #4ade80; /* Accent Green */
    border: 1px solid rgba(74, 222, 128, 0.15);
    box-shadow: 0 0 12px rgba(74, 222, 128, 0.1);
  }
</style>

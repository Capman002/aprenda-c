---
import { getCollection } from 'astro:content';
import Icon from './Icon.astro';

// Obtém todo o conteúdo
const allDocs = await getCollection('course');

// Função auxiliar para organizar por pastas (Módulos)
function groupByModule(docs: typeof allDocs) {
  const groups: Record<string, typeof allDocs> = {};
  
  docs.forEach(doc => {
    // Usa o campo 'module' do frontmatter (migrado) ou fallback para pasta do slug
    let groupKey = doc.data.module || 'Outros';
    
    // Fallback legado se a migração falhar (usa slug folder)
    if (!doc.data.module) {
        const [folder] = doc.slug.split('/');
        groupKey = formatTitle(folder);
    }

    if (!groups[groupKey]) groups[groupKey] = [];
    groups[groupKey].push(doc);
  });

  return groups;
}

const groupedDocs = groupByModule(allDocs);
const currentSlug = Astro.params.slug;

// Mapeamento de Ícones por Título do Módulo (Simples busca de palavra chave)
function getIconForModule(moduleTitle: string) {
    const lower = moduleTitle.toLowerCase();
    if (lower.includes('história') || lower.includes('fundamentos')) return 'book-open';
    if (lower.includes('linguagem') || lower.includes('sintaxe')) return 'code';
    if (lower.includes('hardware') || lower.includes('memória') || lower.includes('mcus')) return 'cpu';
    if (lower.includes('git')) return 'git-branch';
    if (lower.includes('segurança')) return 'shield';
    if (lower.includes('ferramentas')) return 'terminal';
    return 'folder';
}

// Helper removido: formatTitle agora é desnecessário se usarmos o module title direto
function formatTitle(folder: string) {
  const parts = folder.split('-');
  if (parts[0].match(/^\d+$/)) {
    return `Módulo ${parts[0]}: ${parts.slice(1).join(' ')}`;
  }
  return folder.charAt(0).toUpperCase() + folder.slice(1);
}
---

<aside class="sidebar">
  <!-- Header removido (Logo no FloatingMenu) -->

  <div class="sidebar-gamification" data-gamification-summary>
    <div class="g-row">
      <span class="g-label">Nível</span>
      <span class="g-value" data-g-level>—</span>
    </div>
    <div class="g-row">
      <span class="g-label">XP</span>
      <span class="g-value" data-g-xp>—</span>
    </div>
  </div>

  <nav class="nav-scroll" id="sidebar-nav">

    {Object.entries(groupedDocs).sort((a, b) => a[0].localeCompare(b[0])).map(([moduleTitle, docs]) => {
      
      return (
        <div class="module-group" data-module-group data-module-title={moduleTitle}>
          <div class="module-title">
            <Icon name={getIconForModule(moduleTitle)} size={14} />
            <span class="module-name">{moduleTitle}</span>
            <span class="module-progress" data-module-progress>—</span>
          </div>
          
          <div class="module-links">
            {docs.sort((a, b) => a.data.order - b.data.order).map(doc => {
              const isActive = currentSlug === doc.slug;
              return (
                <a 
                  href={`/course/${doc.slug}`} 
                  class:list={['link-item', { active: isActive }]}
                  data-astro-prefetch
                  data-topic-slug={doc.slug}
                >
                  {doc.data.title}
                </a>
              );
            })}
          </div>
        </div>
      );
    })}
  </nav>
</aside>

<script>
  import { gameStore } from '../lib/gameStore';

  // Persist Sidebar Scroll Position
  const sidebarNav = document.getElementById('sidebar-nav');
  const STORAGE_KEY = 'sidebar-scroll-position';

  function renderGamification() {
    try {
      const summary = document.querySelector('[data-gamification-summary]');
      if (!(summary instanceof HTMLElement)) return;

      const state = gameStore.getState();

      const lvl = summary.querySelector('[data-g-level]');
      const xp = summary.querySelector('[data-g-xp]');

      if (lvl instanceof HTMLElement) lvl.textContent = String(state.level);
      if (xp instanceof HTMLElement) xp.textContent = String(state.totalXp);

      const topicLinks = Array.from(document.querySelectorAll('[data-topic-slug]'));
      for (const a of topicLinks) {
        if (!(a instanceof HTMLAnchorElement)) continue;
        const slug = a.dataset.topicSlug;
        if (typeof slug !== 'string') continue;

        const completed = state.topics?.[slug]?.completed ?? false;
        a.classList.toggle('completed', completed);
      }

      const moduleGroups = Array.from(document.querySelectorAll('[data-module-group]'));
      for (const g of moduleGroups) {
        if (!(g instanceof HTMLElement)) continue;
        const links = Array.from(g.querySelectorAll('[data-topic-slug]'));
        const total = links.length;
        let done = 0;

        for (const l of links) {
          if (!(l instanceof HTMLAnchorElement)) continue;
          const slug = l.dataset.topicSlug;
          if (typeof slug !== 'string') continue;
          if (state.topics?.[slug]?.completed) done++;
        }

        const p = g.querySelector('[data-module-progress]');
        if (p instanceof HTMLElement) {
          p.textContent = total > 0 ? `${done}/${total}` : '—';
          p.dataset.state = total > 0 && done === total ? 'done' : done > 0 ? 'partial' : 'todo';
        }
      }
    } catch (err) {
      console.error('SmartSidebar: Error rendering gamification', err);
    }
  }

  // Restore scroll on load
  document.addEventListener('astro:page-load', () => {
    try {
      const sidebarNav = document.getElementById('sidebar-nav');
      const savedPosition = sessionStorage.getItem(STORAGE_KEY);
      
      if (sidebarNav && savedPosition) {
        sidebarNav.scrollTop = parseInt(savedPosition, 10);
      }

      renderGamification();
    } catch (e) {
      console.error('SmartSidebar: Init error', e);
    }
  });

  // Save scroll before unloading or clicking links
  document.addEventListener('astro:before-preparation', () => {
    const sidebarNav = document.getElementById('sidebar-nav');
    if (sidebarNav) {
      sessionStorage.setItem(STORAGE_KEY, sidebarNav.scrollTop.toString());
    }
  });

  window.addEventListener('gamification-update', renderGamification);

</script>

<style>
  .sidebar {
    width: 280px;
    height: 100vh;
    background-color: var(--bg-sidebar);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    padding-top: 32px; /* Reduced from 110px (Menu is centered, doesn't overlap) */
    z-index: 50; 
  }

  .sidebar-gamification {
    margin: 0 20px 16px 20px;
    padding: 12px 14px;
    border: 1px solid var(--border-subtle);
    border-radius: 12px;
    background: rgba(255,255,255,0.02);
    display: grid;
    gap: 8px;
  }

  .g-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
  }

  .g-label {
    font-size: 10px;
    font-weight: 800;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--text-tertiary);
    font-family: 'JetBrains Mono', monospace;
  }

  .g-value {
    font-size: 12px;
    font-weight: 800;
    color: var(--text-primary);
    font-family: 'JetBrains Mono', monospace;
  }

  .nav-scroll {
    flex: 1;
    overflow-y: auto;
    padding: 0 20px 40px 20px;
  }

  /* Scrollbar invisível mas funcional */
  .nav-scroll::-webkit-scrollbar { width: 4px; }
  .nav-scroll::-webkit-scrollbar-thumb { background: transparent; }
  .nav-scroll:hover::-webkit-scrollbar-thumb { background: #333; }

  .home-link {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    color: var(--text-secondary);
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 40px;
    border-radius: 8px;
    transition: all 0.2s ease;
    background: rgba(255,255,255,0.02);
    border: 1px solid transparent;
  }

  .home-link:hover {
    background: rgba(255,255,255,0.05);
    color: #fff;
    border-color: rgba(255,255,255,0.05);
  }

  .module-group {
    margin-bottom: 36px;
  }

  .module-title {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0 16px;
    margin-bottom: 16px;
  }

  .module-progress {
    margin-left: auto;
    font-size: 11px;
    font-weight: 800;
    font-family: 'JetBrains Mono', monospace;
    color: var(--text-tertiary);
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.06);
    background: rgba(255,255,255,0.02);
  }

  .module-progress[data-state="done"] {
    color: #27e2a4;
    border-color: rgba(39, 226, 164, 0.22);
    background: rgba(39, 226, 164, 0.06);
  }

  .module-progress[data-state="partial"] {
    color: var(--accent-blue);
    border-color: rgba(50, 145, 255, 0.22);
    background: rgba(50, 145, 255, 0.06);
  }

  .module-name {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--text-tertiary); /* Zinc 600 - Subtle */
    font-family: 'JetBrains Mono', monospace;
    font-weight: 700;
  }

  .module-links {
    display: flex;
    flex-direction: column;
    gap: 4px; /* Slight gap between links */
  }

  .link-item {
    position: relative;
    display: block;
    padding: 10px 16px; 
    font-size: 14px;
    color: #888; /* Slightly darker than secondary for hierarchy */
    text-decoration: none;
    border-radius: 6px;
    transition: all 0.2s ease;
    border-left: 2px solid transparent; 
  }

  .link-item:hover {
    color: #fff;
    background: rgba(255,255,255, 0.03);
  }

  .link-item.active {
    color: #fff;
    background: linear-gradient(90deg, rgba(50, 145, 255, 0.1) 0%, rgba(0,0,0,0) 100%);
    border-left-color: var(--accent-blue);
    font-weight: 500;
  }

  .link-item.completed {
    color: #e4e4e7;
  }

  .link-item.completed::after {
    content: '';
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: #27e2a4;
    box-shadow: 0 0 8px rgba(39, 226, 164, 0.4);
  }

  @media (max-width: 768px) {
    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      transform: translateX(-100%);
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      width: 85vw; /* Almost full width for better readability on small screens */
      max-width: 320px;
      z-index: 2000; /* Above everything */
      background: var(--bg-app); /* Ensure solid background */
      padding-top: 20px;
    }
    
    /* When open */
    :global(.sidebar.mobile-open) {
      transform: translateX(0);
      box-shadow: 0 0 50px rgba(0,0,0,0.8); /* Deep shadow */
    }
    
    /* Add a backdrop when open? handled in layout or here? 
       For simplicity, we just use the shadow and click-outside logic in the menu component.
    */
  }
</style>

---
title: "Documentação & Licenças Open Source"
description: "Estratégias de licenciamento jurídico e arquitetura de documentação para softwares de longa vida."
difficulty: "Intermediário"
duration: "25 min"
tags: ["Documentation", "Licenses", "Open Source", "Legal", "Architecture"]
order: 6
slug: "git-versionamento/documentacao-licencas"
module: "Módulo 09: Git Versionamento"
quiz:
  - question: "Se você utilizar uma biblioteca com licença GPLv3 em seu software proprietário e distribuí-lo, o que acontece?"
    options:
      - "Nada, pois é Open Source."
      - "Você deve pagar royalties ao autor original."
      - "Todo o seu projeto deve se tornar Open Source sob a licença GPL."
      - "Você apenas precisa citar o autor no README."
    answer: 2
    explanation: "A GPL é uma licença 'Copyleft Forte' (Viral). Ela exige que qualquer trabalho derivado ou vinculado estaticamente seja distribuído sob a mesma licença."
  - question: "Qual licença é recomendada para maximizar a adoção corporativa, permitindo uso em software proprietário sem 'contaminar' o código, mas protegendo contra processos de patentes?"
    options:
      - "MIT"
      - "Apache 2.0"
      - "AGPL"
      - "Unlicense"
    answer: 1
    explanation: "A Apache 2.0 é permissiva como a MIT, mas adiciona uma cláusula expressa de patentes que protege os usuários contra retaliações jurídicas sobre patentes."
  - question: "No framework Diátaxis, qual tipo de documentação foca estritamente no 'aprendizado' prático passo-a-passo para iniciantes?"
    options:
      - "Reference"
      - "Explanation"
      - "How-to Guides"
      - "Tutorials"
    answer: 3
    explanation: "Tutoriais são lições orientadas ao aprendizado, focadas em levar o usuário do ponto A ao B para construir confiança. Diferente de How-to guides, que focam em resolver um problema específico."
---

Engenharia de Software não é apenas código; é sobre a gestão do ciclo de vida, proteção da propriedade intelectual e comunicação eficiente. Um código sem licença é juridicamente "todos os direitos reservados" (copyright exclusivo), tornando-o inutilizável por terceiros sem risco legal. Um código sem documentação é dívida técnica imediata.

> **Nota sobre Maturidade**: O que define "qualidade" ou "senioridade" varia entre contextos e empresas. O que apresento aqui são práticas amplamente testadas na indústria para reduzir atrito e aumentar a manutenibilidade em projetos de longo prazo.

## 1. O Espectro de Licenciamento Open Source

A escolha da licença define a estratégia de distribuição e o modelo de negócios do software.

### Permissivas (Permissive)

Maximizar a adoção. O foco é garantir que o código seja usado, modificado e distribuído com o mínimo de atrito.

- **MIT**: A "regra de ouro" da simplicidade. Permite uso, cópia, modificação, fusão e venda. A única exigência é manter o aviso de copyright original. _Padrão de mercado para bibliotecas Node.js/React._
- **Apache 2.0**: Similar à MIT, mas com um **Grau de Patente Expresso**. Se uma empresa usar meu software e tentar processar eu por violação de patentes relacionadas a ele, a licença delas é revogada automaticamente. _Essencial para colaborações corporativas (Google, Kubernetes)._
- **BSD (2-Clause / 3-Clause)**: Semelhantes à MIT, mas o BSD 3-Clause proíbe o uso do nome dos autores para endossar produtos derivados.

### Copyleft (Viral)

Garantir a liberdade do software perpetuamente. Obriga que trabalhos derivados mantenham a mesma licença.

- **GPLv3 (Strong Copyleft)**: Se eu incluir ou vincular (estaticamente) código GPL no meu projeto, **todo o meu projeto** deve se tornar GPL e ter o código aberto. Empresas costumam evitar GPL em produtos proprietários devido ao "efeito viral".
- **LGPL (Weak Copyleft)**: Um meio-termo. Permite vincular dinamicamente (dll/so) bibliotecas sem contaminar o código proprietário da aplicação principal. _Comum em drivers e bibliotecas do sistema (glibc)._
- **AGPL (Network Copyleft)**: A GPL tem uma falha na era da nuvem: se eu rodar/modifico o software no servidor e disponibiliza via rede (SaaS), eu não "distribuiu" o binário, logo não precisava abrir o código. A AGPL fecha essa brecha: se usuários interagem pela rede, o código deve ser disponibilizado.

### Domínio Público

- **Unlicense / CC0**: Renúncia total dos direitos autorais. Raramente recomendado para software complexo devido à falta de clareza sobre isenção de responsabilidade (liability).

---

## 2. Arquitetura de Documentação Moderna

Documentaçao não é apenas um arquivo de texto. É um sistema de comunicação assíncrona.

### O Framework Diátaxis

Para estruturar documentação robusta, uma abordagem comum é separar o conteúdo em quatro quadrantes:

1.  **Tutoriais**: Foco no _aprendizado_. Passo-a-passo prático para iniciantes.
2.  **How-to Guides**: Foco na _tarefa_. Como resolver um problema específico (ex: "Como configurar CORS").
3.  **Reference**: Foco na _informação_. Assinaturas de API, tipos, configurações (o que o Doxygen/Swagger gera).
4.  **Explanation**: Foco no _entendimento_. Discussões de alto nível, design e trade-offs.

### Documentação de Decisões (ADR)

Projetos longevos exigem memória histórica. Uso **Architecture Decision Records (ADRs)** para registrar decisões importantes.
Formato: _Contexto_, _Decisão_, _Consequências_.

> "Por que escolhi PostgreSQL ao invés de Mongo em 2024? Veja o ADR-002."

### Ferramentas de Build de Documentação

Documentar manualmente é propenso a erro e obsolescência. Utilizo ferramentas que tratam documentação como código (Docs-as-Code).

#### Ferramentas Legadas/Específicas

- **Doxygen**: Padrão para C/C++. Robustez inigualável para extrair referências do código.
- **Sphinx/MkDocs**: Populares no ecossistema Python.

#### A Nova Geração: Build My Docs

Para projetos modernos e complexos, ferramentas tradicionais muitas vezes resultam em documentação fragmentada.

O **Build My Docs** surge como uma solução unificada para "Documentação Full-Stack". Diferente de geradores estáticos simples, ele propõe:

- **Centralização**: Agregar READMEs, ADRs, Docs de API e Manuais em uma única fonte da verdade.
- **Contexto Semântico**: Estruturar a documentação para consumo humano e de LLMs.
- **Automação de Build**: Integração nativa com pipelines de CI/CD para evitar a divergência entre código e documentação.

> **Ponto Chave**: A melhor documentação é aquela que é fácil de escrever e difícil de ignorar. Ferramentas integradas reduzem a fricção cognitiva de manter docs atualizados.

---

## 3. Exemplo Prático: README.md Raiz

Um README eficaz deve responder em 5 segundos: **O que é?**, **Para quem é?** e **Como rodo?**.

````markdown
# Iot-Telemetry-Core

![CI Status](https://img.shields.io/github/actions/workflow/status/org/repo/ci.yml)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

Middleware de alta performance para ingestão de dados IoT usando protocolo MQTT sobre QUIC.

## Arquitetura

Consulte a pasta `/docs` para diagramas C4 e [ADR-001: Seleção do Protocolo de Transporte].

## Quickstart

### Pré-requisitos

- Bun v1.1+
- Container Runtime (Docker/Podman)

### Rodando Localmente

```bash
# 1. Instale dependências
bun install

# 2. Suba a infraestrutura (Broker + DB)
bun run infra:up

# 3. Inicie o serviço
bun run start:dev
```
````

## Como Contribuir

Leia meu [CONTRIBUTING.md](./CONTRIBUTING.md) para diretrizes de Code Review e DCO (Developer Certificate of Origin).

```

```
